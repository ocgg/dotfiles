#!/bin/bash

ROOT=$(dirname "$(realpath "$0")")
REPOS_FILE_NAME="cgc-repos.txt"
REPOS_FILE_PATH="$ROOT/$REPOS_FILE_NAME"

BLUE="\e[0;34m"
CYAN="\e[0;36m"
GREEN="\e[0;32m"
RED="\e[0;31m"
YELLOW="\e[0;33m"
BOLD="\e[1;m"
NC="\e[0m"

WARNINGS=()

USER_EXIT_CODE=33

function print_separator {
    local sign="-"
    printf "%.0s$sign" $(seq 1 "$(tput cols)")
    echo
}

function print_warnings {
    local title="CGC: directory list contains errors!"

    for warning in "${WARNINGS[@]}"; do
        local warnings+="$warning\n"
    done

    notify-send "$title" "\n$warnings\nCheck the file: $REPOS_FILE_PATH"
}

function add_warning {
    WARNINGS+=("$1")
}

function check_repo_file {
    [ -f "$REPOS_FILE_PATH" ] && return 0

    local title="CGC: Repo list file not found!"
    touch "$REPOS_FILE_PATH"
    {
        echo "# - Lines beginning with '#' are ignored";
        echo "# - Empty lines are ignored";
        echo "# - Write absolute paths to your repos, one per line"
    } >> "$REPOS_FILE_PATH"
    message="The file was created in $REPOS_FILE_PATH.\nPlease provide absolute paths to git directories in that file, one path a line, and retry."
    notify-send "$title" "$message"
    return 1
}

function check_repo_dir {
    if [[ -z "$1" || "$1" =~ ^# ]]; then
        return 1
    elif [ ! -d "$1" ]; then
        add_warning "Directory not found: $1"
        return 1
    elif ! git -C "$1" rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        add_warning "Not a git repository: $1"
        return 1
    fi
    return 0
}

# NOTE: "exit" commands here just terminate the subshell from where menu() is
# called, not the entire script.
function unclean_menu {
    while true; do
        echo -e "${YELLOW}${BOLD}[AUTO]-commit & push${NC}, [d]iff, [c]ommit, [cd] to repo, [n]ext, [q]uit"
        read -r -p "> " action < /dev/tty
        case "$action" in
            "" | auto)
                git add --all
                git commit -m "auto commit" || exit 1
                git push && break;;
            d)
                git diff;;
            c)
                read -r -p "Message: " msg < /dev/tty
                git add --all
                git commit -m "$msg" || exit 1
                read -r -p "Run git push ? (y/n) > " push < /dev/tty
                [ "$push" = "y" ] && git push && break;;
            cd)
                echo
                echo -e "${GREEN}Opening $1 in a new session...${NC}"
                echo -e "${GREEN}'exit' or ctrl+d to come back.${NC}"
                cd "$1" || exit
                $SHELL -i
                break;;
            n)
                break;;
            q)
                exit $USER_EXIT_CODE;;
        esac
    done
}

# NOTE: "exit" commands here just terminate the subshell from where menu() is
# called, not the entire script.
function clean_menu {
    while true; do
        echo -e "${YELLOW}${BOLD}[P]ull${NC}, [cd] to repo, [n]ext, [q]uit"
        read -r -p "> " action < /dev/tty
        case "$action" in
            "" | p)
                git pull && break;;
            cd)
                echo
                echo -e "${GREEN}Opening $1 in a new session...${NC}"
                echo -e "${GREEN}'exit' or ctrl+d to come back.${NC}"
                cd "$1" || exit
                $SHELL -i
                break;;
            n)
                break;;
            q)
                exit $USER_EXIT_CODE;;
        esac
    done
}

check_repo_file || exit 1

while IFS= read -r repo_dir; do
    check_repo_dir "$repo_dir" || continue
    echo "Checking repo: $repo_dir"
    echo

    (
        cd "$repo_dir" || exit 2
        repo_name="${CYAN}${BOLD}$(basename "$(realpath .)")${NC}"
        currentbranch="${BLUE}${BOLD}git:(${RED}${BOLD}$(git branch --show-current)${BLUE})${NC}"

        if [ -n "$(git status --porcelain)" ]; then
            echo -e "${YELLOW}âœ—${NC} $repo_name $currentbranch"
            git -c color.status=always status --short | sed 's/^/  /'
            echo
            unclean_menu "$repo_dir"
        else
            echo -e "${GREEN}CLEAN:${NC} $repo_name $currentbranch"
            clean_menu "$repo_dir"
        fi
    )
    output_code=$?
    [ $output_code -eq $USER_EXIT_CODE ] && exit
    [ $output_code -eq 1 ] && exit 1
    echo
    print_separator
done < "$REPOS_FILE_PATH"

[ ${#WARNINGS[@]} -ne 0 ] && print_warnings
